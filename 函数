对于可变参数和不可变参数，在经历一个函数之后的结果是不同的
如一个不可变的int a=23 如果在函数中a=100,在函数结束后a依然是23
但是如果是一个列表 l=[23,34] 在函数中 l.append(24),这样函数结束后这个列表仍然会留下这个24
所以在写函数的时候小心一点，意识到这也是一个容易导致BUG的点
不可变不会影响，可变可以影响

当函数尝试返回多个值时，会返回一个元组（自动打包）

如果你不知道函数会往里面传几个 
def fun(*args) 
这样往里面传几个都可以 最后这个args是元组

def fun(**args) 这样往里面丢什么，args都是一个字典
举个例子：
def fun(**args):
    print(args)

fun(a=10,b=20,c=30) 这样打印的字典就是{'a':10,'b':20,'c':30} 似乎这样生成字典的方式会快一点？

def fun(a,b,c):
    print('a=',a)
    print('b=',b)
    print('c=',c)

fun(10,20,30)
lst=[11,22,33]
fun(*lst)
fun(a=100,c=300,b=200)

以上这段代码，建议好好研究一下
fun(*lst) 这个*可以自动把列表拆成三个元素对应的塞进a,b,c 
类似的，字典 fun(**dic) 加两个星号就可以传字典
dic={'a':111,'b':222,'c':333}
fun(**dic)
注意，字典的话主函数和分函数里面的变量名就要相同，字典里面的key不能乱写

fun(a=100,c=300,b=200) 这一行会输出的是100,200，300，因为这样是关键值赋值，会自动对应